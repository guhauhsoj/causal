---
title: "Propensity Stratification"
output: html_document
---
```{r}
library(ggplot2)
#USDA Data on food accessability by census tract
USDA <- read.csv("./data/USDA.csv")
#CDC Data on average life expectancy by census tract
life_exp <- read.csv("./data/US_A.csv")

#removes some track data do to missing observations in life expectancy data, 74,000 rows to 65000 rows
USDA_Data <- dplyr::inner_join(life_exp, USDA, by = c("Tract.ID"="CensusTract") )


```

## Preprocessing and covariate selection

Include important covariates: Median Household income, % of households who recieve SNAP, % who have access to a vehicle. Assume strong ignorability given these covariates

```{r}
#list covariates, response and treatment
race <- c("TractBlackper","TractHispanicper")
myvars <- c("e.0.","LA1and10","PovertyRate","MedianFamilyIncome", "TractSNAPper","Urban","TractHUNVper",race)


#normalize SNAP as a % of hoursing units in the tract, % of houses with no vehicle in the tract and % of each race in tract
USDA_Data$TractSNAPper = USDA_Data$TractSNAP / USDA_Data$OHU2010
USDA_Data$TractHUNVper = USDA_Data$TractHUNV / USDA_Data$OHU2010

USDA_Data$TractBlackper = USDA_Data$TractBlack/USDA_Data$POP2010
USDA_Data$TractWhiteper = USDA_Data$TractWhite/USDA_Data$POP2010
USDA_Data$TractHispanicper = USDA_Data$TractHispanic/USDA_Data$POP2010



#create new data and filter NA,NAN and Inf
USDA_new <- USDA_Data[myvars]
#make sure if its not systematically missing data
USDA_new <- USDA_new[Reduce(`&`, lapply(USDA_new, function(x) !is.na(x)  & is.finite(x))),]
USDA_new <- USDA_new[USDA_new$MedianFamilyIncome !=0,]
USDA_new <- USDA_new[USDA_new$TractSNAPper <= 1 & USDA_new$TractHUNVper <= 1,]


```

# Propensity Score stratification

```{r}

Neyman_SRE = function(z, y, x)
{
  xlevels = unique(x)
  K       = length(xlevels)
  PiK     = rep(0, K)
  TauK    = rep(0, K)
  varK    = rep(0, K)
  for(k in 1:K)
  {
    xk         = xlevels[k]
    zk         = z[x == xk]
    yk         = y[x == xk]
    PiK[k]     = length(zk)/length(z)
    TauK[k]    = mean(yk[zk==1]) - mean(yk[zk==0])
    varK[k]    = var(yk[zk==1])/sum(zk) + 
      var(yk[zk==0])/sum(1 - zk)
  }
  
  return(c(sum(PiK*TauK), sqrt(sum(PiK^2*varK))))
}

```

```{r}
covars <- c("PovertyRate","MedianFamilyIncome","TractSNAPper","TractHUNVper","Urban")

x <- USDA_new[covars]
z <- USDA_new$LA1and10
y <- USDA_new$e.0.

x <- scale(x)

pscore <- glm(z ~ x, family = binomial)$fitted.values

n.strata = c(5, 10, 20, 50, 80)
strat.res = sapply(n.strata, 
                   FUN = function(nn){
                     q.pscore = quantile(pscore, (1:(nn-1))/nn)
                     ps.strata = cut(pscore, breaks = c(0,q.pscore,1), 
                                     labels = 1:nn)
                     Neyman_SRE(z, y, ps.strata)             
                   })

rownames(strat.res) = c("est", "se")
colnames(strat.res) = n.strata
round(strat.res, 3)

n <- 5
Bcheck = sapply(1:dim(x)[2],
                FUN = function(px){
                  q.pscore = quantile(pscore, (1:(n-1))/n)
                  ps.strata = cut(pscore, breaks = c(0,q.pscore,1), 
                                  labels = 1:n)
                  Neyman_SRE(z, x[, px], ps.strata)
                })

dat_balance = data.frame(est = Bcheck[1, ],
                         upper = Bcheck[1, ] + 1.96*Bcheck[2, ],
                         lower = Bcheck[1, ] - 1.96*Bcheck[2, ],
                         cov = factor(1:ncol(x)))
ggplot(dat_balance) + 
  geom_errorbar(aes(x = cov,
                    ymin = lower,
                    ymax = upper),
                alpha = 0.6) + 
  geom_point(aes(x = cov,
                 y = est),
             alpha = 0.6) +
  geom_hline(aes(yintercept = 0),
             alpha = 0.3) + 
  theme_bw() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.title.y=element_blank()) +
  xlab("balance check based on stratification with K=5")  +
  ggtitle("Covariate balance Propensity stratification")

```

